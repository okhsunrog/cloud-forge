---
- name: Configure sysctl
  sysctl:
    name: "{{ item }}"
    value: "{{ sysctl_settings[item] }}"
    sysctl_file: /etc/sysctl.conf
    reload: yes
  with_items: "{{ sysctl_settings.keys() | list }}"
  notify: reload sysctl

- name: Install iptables-persistent
  debconf:
    name: iptables-persistent
    question: "{{ item }}"
    value: "true"
    vtype: boolean
  loop:
    - iptables-persistent/autosave_v4
    - iptables-persistent/autosave_v6

- name: Ensure iptables-persistent package
  apt:
    name: iptables-persistent
    state: present

# NAT rules for VPN subnets
- name: Configure NAT rules
  iptables:
    table: nat
    chain: POSTROUTING
    jump: MASQUERADE
    source: "{{ item.value }}"
    out_interface: "{{ nat_out_interface | default('eth0') }}"
  with_dict: "{{ vpn_subnets }}"
  when: vpn_subnets is defined
  notify: save iptables

# Block internal traffic in friends VPN network (Moscow only)
- name: Block internal traffic in friends VPN network
  iptables:
    chain: FORWARD
    source: "{{ wg_networks.ocserv_friends }}"
    destination: "{{ item }}"
    jump: DROP
  loop:
    - "{{ wg_networks.ocserv_friends }}"
    - "{{ wg_networks.ocserv_personal }}"
    - "{{ wg_networks.clients }}"
  when: wg_networks.ocserv_friends is defined and ocserv_instances is defined
  notify: save iptables

# Block untrusted WireGuard peers from reaching any VPN subnet
# Untrusted peers can only access the internet (via Europe tunnel)
- name: Block untrusted WireGuard peers from reaching VPN subnets
  iptables:
    chain: FORWARD
    source: "{{ item[0].ip }}/32"
    destination: "{{ item[1] }}"
    jump: DROP
  loop: "{{ vault_wg_peers | selectattr('trusted', 'defined') | selectattr('trusted', 'equalto', false) | product([wg_networks.clients, wg_networks.amneziawg, wg_networks.upstream, wg_networks.ocserv_personal, wg_networks.ocserv_friends]) | list }}"
  loop_control:
    label: "{{ item[0].name }} -> {{ item[1] }}"
  when:
    - vault_wg_peers is defined
    - wireguard_interfaces is defined
  notify: save iptables

# Policy routing for tunnel (Moscow VPS)
- name: Create routing table for tunnel
  lineinfile:
    path: /etc/iproute2/rt_tables
    line: "100 tunnel"
    state: present
  when: route_through_tunnel | default(false)

- name: Setup tunnel routing service
  template:
    src: tunnel-routing.service.j2
    dest: /etc/systemd/system/tunnel-routing.service
    mode: '0644'
  when: route_through_tunnel | default(false)
  notify: reload systemd

- name: Enable tunnel routing service
  systemd:
    name: tunnel-routing
    enabled: yes
    daemon_reload: yes
  when: route_through_tunnel | default(false)

- name: Deploy networkd-dispatcher hook for tunnel routing
  template:
    src: tunnel-routing-dispatcher.j2
    dest: /etc/networkd-dispatcher/routable.d/50-tunnel-routing
    mode: '0755'
  when: route_through_tunnel | default(false)

# Standard firewall rules
- name: Allow established connections
  iptables:
    chain: INPUT
    jump: ACCEPT
    ctstate: ESTABLISHED,RELATED
  notify: save iptables

- name: Configure firewall rules for external ports
  iptables:
    chain: INPUT
    jump: ACCEPT
    protocol: "{{ item.value.type }}"
    destination_port: "{{ item.value.port }}"
  loop: "{{ ports.external | dict2items }}"
  when:
    - ports.external is defined
    - item.value.type != 'icmp'
    - item.value.type != 'both'
  notify: save iptables

- name: Configure firewall rules for ports that need both TCP and UDP
  iptables:
    chain: INPUT
    jump: ACCEPT
    protocol: "{{ item[1] }}"
    destination_port: "{{ item[0].value.port }}"
  loop: "{{ ports.external | dict2items | product(['tcp', 'udp']) | list }}"
  when:
    - ports.external is defined
    - item[0].value.type == 'both'
  notify: save iptables

- name: Configure firewall rules for UDP port ranges
  iptables:
    chain: INPUT
    jump: ACCEPT
    protocol: udp
    destination_port: "{{ ports.external.coturn_relay_min.port }}:{{ ports.external.coturn_relay_max.port }}"
  when: ports.external.coturn_relay_min is defined
  notify: save iptables

- name: Allow ICMP (Ping)
  iptables:
    chain: INPUT
    jump: ACCEPT
    protocol: icmp
    icmp_type: any
  notify: save iptables

- name: Allow loopback interface
  iptables:
    chain: INPUT
    jump: ACCEPT
    in_interface: lo
  notify: save iptables

- name: Allow traffic from WireGuard interfaces
  iptables:
    chain: INPUT
    jump: ACCEPT
    in_interface: "{{ item.interface }}"
  loop: "{{ wireguard_interfaces | default([]) }}"
  loop_control:
    label: "{{ item.name }}"
  when: wireguard_interfaces is defined
  notify: save iptables

- name: Set default policies
  iptables:
    chain: "{{ item.chain }}"
    policy: "{{ item.policy }}"
  loop:
    - {chain: "FORWARD", policy: "ACCEPT"}
    - {chain: "OUTPUT", policy: "ACCEPT"}
    - {chain: "INPUT", policy: "DROP"}
  notify: save iptables
